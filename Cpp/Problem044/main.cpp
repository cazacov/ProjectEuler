/* Project Euler
 * Problem 44: Pentagon numbers
 * https://projecteuler.net/problem=44
 *
 * Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:
 * 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
 * It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.
 * Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal
 * and D = |Pk − Pj| is minimised; what is the value of D?
 */

#include <iostream>
#include <cmath>
#include <climits>

const int N = 400000;

bool is_perfect_square(const long number)
{
    // Based on ideas from https://www.urbanpro.com/class-ix-x-tuition/fastest-way-how-to-check-if-a-number-is-a

    auto last_digit = number % 10;

    if (last_digit == 2 || last_digit == 3 || last_digit == 7 || last_digit == 8) {
        return false;
    }

    auto tens_digit = (number / 10) % 100;

    if (last_digit == 0 && tens_digit != 0) {
        return false;
    }
    if (last_digit == 5 && tens_digit != 2) {
        return false;
    }
    if (last_digit == 6 && !(tens_digit & 0x01)) {    //tens must be odd
        return false;
    }
    if ((last_digit == 1 || last_digit == 4 || last_digit == 9) && tens_digit & 0x01) {// tens must be event
        return false;
    }

    long sq = lround(sqrt(number));
    return sq*sq == number;
}


int is_pentagon(const long number)
{
    auto test = number * 12 + 1;
    if (!is_perfect_square(test)) {
        return false;
    }
    return lround(sqrt(test)) % 6 == 5;
}

int main() {

    long min_d = LONG_MAX;
    long min_p1 = 0;
    long min_p2 = 0;

    long j = 2;
    do {
        long pj = 3*j*j - j;

        double lower_limit = 1;
        if (min_d < LONG_MAX) { // We have already found at least one D

            // Pj - Pk cannot be less than D
            // We can estimate lower limit of k knowing that Pk must be greater than (Pj - D)
            lower_limit = (sqrt((pj - min_d) *  12 + 1)  + 1)/ 6;
            if (lower_limit > j -1) { // The gap between Pk and Pj is smaller than D
                // Smaller D cannot exist. Break the search.
                break;
            }
        }

        for (long k = (int)lower_limit; k < j; k++) {
            long pk = 3*k*k - k;

            auto sum = pj + pk;
            if (!is_pentagon(sum)) {
                continue;
            }

            auto dif = pj - pk;
            if (!is_pentagon(dif)) {
                continue;
            }

            if (dif < min_d) {
                min_d = dif;
                min_p1 = pk;
                min_p2 = pj;
                std::cout << min_p1 / 2 << " (P" << k << ") + " << min_p2 / 2 << " (P" << j << ") = " << sum / 2 << std:: endl;
                std::cout << min_p2 / 2 << " (P" << j << ") - " << min_p1 / 2 << " (P" << k << ") = " << min_d / 2 << std:: endl;
            }
        }
        j++;
    } while (true);

    std::cout << "Answer: " << min_d  / 2 << std:: endl;
}